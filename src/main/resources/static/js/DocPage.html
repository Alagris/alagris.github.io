<!DOCTYPE html>
<!-- saved from url=(0053)https://getbootstrap.com/docs/4.5/examples/jumbotron/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="Mark Otto, Jacob Thornton, and Bootstrap contributors">
    <meta name="generator" content="Jekyll v4.1.1">
    <title>Solomonoff - Documentation</title>

    <link rel="canonical" href="https://getbootstrap.com/docs/4.5/examples/jumbotron/">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

    <!-- Favicons -->
    <link rel="apple-touch-icon" href="images/ph1.png" sizes="180x180">
    <!--    <link rel="icon" href="https://getbootstrap.com/docs/4.5/assets/img/favicons/favicon-32x32.png" sizes="32x32" type="image/png">-->
    <!--    <link rel="icon" href="https://getbootstrap.com/docs/4.5/assets/img/favicons/favicon-16x16.png" sizes="16x16" type="image/png">-->
    <link rel="manifest" href="https://getbootstrap.com/docs/4.5/assets/img/favicons/manifest.json">
    <link rel="mask-icon" href="https://getbootstrap.com/docs/4.5/assets/img/favicons/safari-pinned-tab.svg" color="#563d7c">
    <link rel="icon" href="images/ph1.ico">
    <meta name="msapplication-config" content="/docs/4.5/assets/img/favicons/browserconfig.xml">
    <meta name="theme-color" content="#563d7c">

    <style>body {
        color: black;
        padding: 5px;
     }
     </style>
    <style>
      .bd-placeholder-img {
        font-size: 1.125rem;
        text-anchor: middle;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      @media (min-width: 768px) {
        .bd-placeholder-img-lg {
          font-size: 3.5rem;
        }
      }
    </style>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" integrity="sha384-w1Q4orYjBQndcko6MimVbzY0tgp4pWB4lZ7lr30WKz0vr/aWKhXdBNmNb5D92v7s" crossorigin="anonymous"></script>

    <!-- Custom styles for this template -->
    <!-- <link href="./Jumbotron Template · Bootstrap_files/jumbotron.css" rel="stylesheet"> -->
</head>
<body data-new-gr-c-s-check-loaded="14.984.0" data-gr-ext-installed="">
<!-- <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/">Start</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
                <a class="nav-link" href="/compiler">Compiler</a>
            </li>
            <li class="nav-item active">
                <a class="nav-link" href="/DocPage">Documentation <span class="sr-only">(current)</span></a>
            </li>
             <li class="nav-item">
              <a class="nav-link disabled" href="https://getbootstrap.com/docs/4.5/examples/jumbotron/#" tabindex="-1" aria-disabled="true">Features</a>
            </li> -->
            <!-- <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More</a>
                <div class="dropdown-menu" aria-labelledby="dropdown01">
                    <a class="dropdown-item" href="https://getbootstrap.com/docs/4.5/examples/jumbotron/#">Contact</a>
                    <a class="dropdown-item" href="https://getbootstrap.com/docs/4.5/examples/jumbotron/#">Support Product</a>
                    <a class="dropdown-item" href="https://getbootstrap.com/docs/4.5/examples/jumbotron/#">Something else here</a>
                </div>
            </li>
        </ul> -->
        <!--        <form class="form-inline my-2 my-lg-0">-->
        <!--            <input class="form-control mr-sm-2" type="text" placeholder="Search" aria-label="Search">-->
        <!--            <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>-->
        <!--        </form>-->
    <!-- </div>
</nav> --> 

<main role="main">

    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron">
        <div class="container">
            <h1 class="display-3">Solomonoff Compiler Documentation</h1>
            <br/>
            <p>Solomonoff Compiler is an innovative solution designed for ..</p>
            <!-- <p><a class="btn btn-primary btn-lg" href="/compiler" role="button">Get Started </a></p> -->
        </div>
    </div>


    <nav id="navbar-example3" class="list-group navbar-light bg-light">
        <a class="navbar-brand" href="#">Content <br> Solomonoff - transducer compiler with inductive inference</a>
        <nav class="nav nav-pills flex-column">
            <a class="nav-link active" href="#about">About</a>
            <a class="nav-link" href="#regular-expressions">Regular expressions</a>
            <a class="nav-link" href="#vernacular-language">Vernacular language</a>
            <a class="nav-link" href="#Type-system">Type system</a>
            <a class="nav-link" href="#reflections">Reflections</a>
            <a class="nav-link" href="#pseudo minimization">Pseudo minimization</a>
            <a class="nav-link" href="#external-functions">External functions</a>
            <a class="nav-link" href="#linear-types">Linear types</a>
            <a class="nav-link" href="#composition">Composition</a>
            <a class="nav-link" href="#usage">Usage</a>
            <a class="nav-link" href="#references">References</a>
            <a class="nav-link" href="#benchmarks-thrax-vs-solomonoff">Benchmarks Thrax vs Solomonoff</a>
            
            <!-- <nav class="nav nav-pills flex-column">
                <a class="nav-link ml-3 my-1" href="#item-3-1">Item 3-1</a>
                <a class="nav-link ml-3 my-1" href="#item-3-2">Item 3-2</a>
            </nav> -->
        </nav>
    </nav>
    <br/>
    <br/>
    <div data-spy="scroll" data-target="#navbar-example3" data-offset="0">
        






    <h1 id="sample-markdown">Solomonoff - transducer compiler with inductive inference</h1>
    
    <h2 id="about">About</h2>
    <p><strong>This project focuses on research in the field of automata theory and inductive inference</strong>. While many existing libraries already provide support for general purpose automata and implement various related algorithms, this project takes a slightly different approach. The primary tool for working with the library, is through doman specific language of regular expressions. Most of the things can be done without writing even a single line of Java code. </p>
    <p><strong>Compilation of regular expressions is very efficient</strong> thanks to Glshkov&#39;s construction. Hence all operations of concatenation, union, Kleene closure (including <code>*</code>, <code>+</code>, <code>?</code>) are constant-time operations. Moreover, the automata will have only as many states as there are symbols in regular expression. </p>
    <p><strong>All automata are nondeterministic functional</strong> subsequential  weighted transducers. 
    The primary semiring of weights is arctic lexicographic semiring (more options will come in the future). Compiler always enforces functionality (that is, at most one output can be printed for each input) through an efficient transducer squaring algorithm (time complexity is quadratic). Moreover, all transitions are ranged - that is they don&#39;t accept just a single symbol but instead they span entire ranges of symbols. Therefore expressions like <code>.</code> translate to just one single transition. Glushkov&#39;s construction gives us a guarantee that there are only as many transitions as there are symbols in regular epxression (each range <code>[a-z]</code> counts as one). </p>
    <p><strong>All regular expressions are strongly typed</strong>. The type system is polymorpic and (unlike in most Turing-complete languages), the typechecking is not done through unification algorithm, but rather the language inclusion. All types are regular expressions themselves as well, although it is required that they are deterministic (that is, the automaton produced with Glushkov&#39;s construction is deterministic). This way, language inclusion can be checked by performing product of automata (quadratic time-complexity). In some places (explained below) also nondeterministic language inclusion is checked, but unfortunately it can only be done with subset construction (exponential time complexity). Hence, user is advised to use nondeterministic typechecking only when absolutely necessary. </p>
    <p><strong>All automata are very small</strong> thanks to <ins>nondeterministic pseudo-minimisation</ins>! 
    Unlike most other libraries that implement minimisation through construction of minimal DFA, 
    here we actually perform pseduo-minimisation on nondeterministic transducers. 
    The algorithm uses heuristics inspired by Brzozowski&#39;s construction and Kameda-Weiner&#39;s 
    NFA minimisation. Unfortunately performing full minimisation on NFA is a hard problem, 
    which requires exponential complexity. Our algorithm is O(n log n) on average 
    (and O(n^2 log n) in a very unlikely pessimistic case) and 
    attempts to reduce size of automaton as much as possible, 
    without actually searching for the smallest one. 
    Note that not finding the smallest nondeterministic transducer, 
    should not be a problem, because the NFA are often much smaller than even the smallest DFA. 
    Moreover, thanks to glushkov&#39;s construction, all compiled automata are often in practice 
    smaller than minimal DFA even without pseudo-minimisating them.</p>
    <p><strong>Evaluation is very efficient</strong> thanks to guarantees of lexicographic weights. 
    In pessimistic case evaluation is quadratic, but after performing pseudo-minimisation, 
    it is in practice often close to being linear (optimistic case being deterministic automata, 
    whose evaluation has linear time complexity).  </p>
    <p><strong>Transducer composition is lazy</strong> because otherwise it would pose the danger of exponentially exploding size of automata (composition of two transducers is quadratic, but if composition is used multiple times in a regular expression then, that would lead to exponential number of states in worst case).
    However, making composition lazy has some advantages - this compiler allows for invoking external functions written in Java. Hence you can ad-hoc mix regular expressions with custom Java functions. If really necessary, there is also a function for explicitly performing composition in non-lazy manner, but it should be used with caution and only applied when automata are reasonably small.</p>
    <p><strong>External functions</strong> can be called to add even more features. For instance, instead of making <code>import some.other.module</code> a keyword (like in most other languages), here <code>import!(&#39;some/other/module.mealy&#39;)</code> is an external function. It&#39;s possible to read automata in various formats such as AT\&amp;T, DOT and compressed binary.</p>
    <p><strong>Inductive inference/machine learning</strong> can be extensively used with ease. At the moment all inference functions are provided by LearnLib (Solomonoff is compatible with LearnLib and AutomataLib). More algorithms, specific to transducers will be added soon. </p>
    <p><strong>Solomonoff implementation is small and generic</strong>. It takes up roughly 10-15 classes and many algrithms are written in a clean reusable manner. Because the main way of interaction with the library is via its domain specific language, most of the underlying implementation is free to be changed and reworked in drastic ways at any time. The Java API accessible to end-users is very minimalist just like Java&#39;s <code>Pattern.compile</code> (you don&#39;t see things like <code>Pattern.union</code> or <code>Pattern.kleeneClosure</code>). This means that our library has a lot more room for refactoring, simplyfing and optimising the implementation.  </p>
    <p><strong>The primary philosophy used in implementing this library</strong> is the top-down approach and features are added conservatively in a well thought-through manner. No features will be added ad-hoc. Everything is meant to fit well together and follow some greater design strategy. For comparision, consider the difference between OpenFst and Solomonoff.</p>
    <ul>
    <li><p>OpenFst has <code>Matcher</code> that was meant to compactify ranges. 
    In Solomonoff all transitions are ranged and follow the theory of symbolic automata. 
    They are well integrated with regular expressions and Glushkov&#39;s construction. 
    They allow for more efficient squaring and subset construction. 
    Instead of being an ad-hoc feature, they are well integrated everywhere.</p>
    </li>
    <li><p>OpenFst has no built-in support for regular expression and it was added 
    only later in form of Thrax grammars, that aren&#39;t much more than another API for calling 
    library functions. In Solomonoff the regular expressions <strong>are</strong> the library. 
    Instead of having separate procedures for union, concatenation and Kleene closure, 
    there is only one procedure that takes arbitrary regular expression and compiles it in batch. 
    This way everything works much faster, doesn&#39;t lead to introduction of any &epsilon;-transitions 
    (in Solomonoff, &epsilon;-transitions aren&#39;t even implemented, because 
    they were never needed thanks to Glushkov&#39;s construction). This leads to significant 
    differences in performance. You can see benchmarks below. </p>
    </li>
    <li><p>Many operations are implemented in &quot;better&quot; way. For example   </p>
    <ul>
    <li>Solomonoff has no need for <code>ArcSort</code> because all arcs are always sorted</li>
    <li>Solomonoff has no <code>Optimise</code> because compiler decides much better when to optimise things</li>
    <li>Solomonoff has no <code>RmEpsilon</code>, because it has no epsilons in the first place</li>
    <li>Solomonoff has no <code>CDRewrite</code> because the same effect can be achieved much more efficeintly with lexicographic weights and Kleene closure.</li>
    <li>In OpenFST if you perform <code>(&quot;a&quot;:&quot;b&quot;):&quot;c&quot;</code> you get as a result <code>&quot;b&quot;:&quot;c&quot;</code>. OpenFST treats <code>:</code> as a binary operation. Solomonoff on the other hand treats <code>:</code> as unary operation. <code>(&quot;a&quot;:&quot;b&quot;):&quot;c&quot;</code> results in <code>&quot;a&quot;:&quot;bc&quot;</code>. In fact <code>:&#39;b&#39;</code> is treated as <code>&#39;&#39;:&#39;b&#39;</code> and <code>&#39;a&#39;:&#39;b&#39;</code> is merely a syntactic sugar for <code>&#39;a&#39; &#39;&#39;:&#39;b&#39;</code>. You can write for example <code>:&#39;b&#39; &#39;a&#39;</code>. The strings prefixed with <code>:</code> are the output strings, whereas strings without <code>:</code> are the input strings. You can very easily perform inversion of automaton by turning input strings into output strings and vice-versa. For example in Thrax you have <code>Inverse[&quot;a&quot;:&quot;b&quot;]</code> which results in <code>&quot;b&quot;:&quot;a&quot;</code>. In Solomonoff the inverse of <code>&#39;a&#39;:&#39;b&#39;</code> becomes <code>:&#39;a&#39; &#39;b&#39;</code>. Very stright-forward. The semantics of <code>:</code> in OpenFST strip the output of the left-hand side. In fact, <code>X:Y</code> in OpenFST translates more literally to <code>stripOutput[X]:Y</code> in Solomonoff. </li>
    <li><p>Thrax supports so called &quot;temporary&quot;/&quot;outside of alphabet&quot; symbols. Any time you write <code>&quot;[NEW_SYMBOL]&quot;</code> it will take some large UNICODE codepoint hoping that it&#39;s not used anywhere else. In Solomonoff this is not necessary, because using type system is much better suited for this task. You can just write </p>
    <pre><code>x = <span class="hljs-string">'abcd'</span> <span class="hljs-comment">// some regex</span>
    x &lt;: [a-z]* <span class="hljs-comment">//ensure that it uses specific alphabet</span>
    z = x &lt;<span class="hljs-number">404</span>&gt; x <span class="hljs-comment">// use codepoint 404 as some "external symbol"</span>
    z &lt;: <span class="hljs-comment">([a-z]|&lt;404&gt;)</span>*
    </code></pre></li>
    </ul>
    </li>
    </ul>
    <p><strong>For embedded systems</strong> Java might not be the ideal language of choice, hence we (will soon) provide C backend. The compiler itself will remain written purely in Java, but there will be alternative C runtime capable of running all automata as well. Moreover, for places where resources are really tight, Solomonoff will offer direct compilation of transtucers into C code (similarly to how Flex and Bison or other parser generators work, except that Solomonoff will generate transducers instead of parsers). </p>
    <p><strong>Compilation of UNIX regexes and Thrax grammars</strong> will be soon supported as well. By supporting UNIX, Solomonoff will try to compete with Google&#39;s RE2 as well. All this will be done with active learning. This approach has numerous advantages. </p>
    <ul>
    <li>First there is no need to explicitly write and converters. You only give Solomonoff some Java function that is of type <code>String someFunction(String input){...}</code> and Solomonoff will treat it as oracle for grammatical inference. For example <code>someFunction</code> might call <code>input.replaceAll(&quot;some|complicated(regex)*&quot;,&quot;substitution&quot;)</code> (even multiple times) and Solomonoff will learn and produce some transducer. This way lookahead&#39;s and lookbehind&#39;s will be supported (so it can do more than Google&#39;s RE2 library). </li>
    <li>Second it will not only convert but also hugely optimise all regexes. </li>
    <li>Third it will be very generic. It could in fact learn any Java function, as long as it&#39;s functionality can be expressed by a transducer (context free or context sensitive transductions are not supported). Hence Solomonoff might be a perfect tool for simplify your ancient codebase of spaghetti regexes, written by &quot;some guy who no longer works here&quot;. </li>
    </ul>
    <h2 id="regular-expressions">Regular expressions</h2>
    <p>The language supports regular expressions of the following form</p>
    <pre><code><span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> some <span class="hljs-keyword">literal</span> <span class="hljs-built_in">string</span>'
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span>' | <span class="hljs-symbol">'union</span> <span class="hljs-keyword">of</span> languages'
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> Kleene closure <span class="hljs-keyword">of</span> zero <span class="hljs-keyword">or</span> more elements'*
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> Kleene closure <span class="hljs-keyword">of</span> one <span class="hljs-keyword">or</span> more elements'+
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> Kleene closure <span class="hljs-keyword">of</span> zero <span class="hljs-keyword">or</span> one elements'?
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span>' : <span class="hljs-symbol">'output</span>'
    (<span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span>' : <span class="hljs-symbol">'output</span> under Kleene closure')*
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span>' : <span class="hljs-symbol">'also</span> output under Kleene closure'*
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span>' : (<span class="hljs-symbol">'invalid</span> because it leads <span class="hljs-keyword">to</span> nondeterminism'*)
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> invalid':<span class="hljs-symbol">'because</span> it leads <span class="hljs-keyword">to</span> nondeterminism' | <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> invalid':<span class="hljs-symbol">'because</span> it leads <span class="hljs-keyword">to</span> nondeterminism as well'
    <span class="hljs-symbol">'this</span>' [a-z] <span class="hljs-symbol">'is</span> a <span class="hljs-keyword">range</span>'
    <span class="hljs-symbol">'more</span> ranges:' [a-z][a-z][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*[a-z]
    <span class="hljs-symbol">'not</span> a <span class="hljs-keyword">range</span> [a-z]'
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> epsilon output':''
    '':<span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> output from epsilon'
    '':<span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> invalid because it leads <span class="hljs-keyword">to</span> nondeterminism'*
    <span class="hljs-symbol">'this</span>' <span class="hljs-number">1</span> <span class="hljs-symbol">'is</span> weighted expression'
    <span class="hljs-symbol">'this</span> <span class="hljs-keyword">is</span> weighted Kleen closure' <span class="hljs-number">3</span> *
    <span class="hljs-symbol">'going</span> ' ( <span class="hljs-number">3</span> <span class="hljs-symbol">'here</span> <span class="hljs-keyword">is</span>':<span class="hljs-symbol">'more</span> important' | <span class="hljs-number">2</span> <span class="hljs-symbol">'here</span> <span class="hljs-keyword">is</span>':<span class="hljs-symbol">'less</span> important') ' hence there <span class="hljs-keyword">is</span> no nondeterminism'
    </code></pre><h2 id="vernacular-language">Vernacular language</h2>
    <p>The language of regular expressions gains additional power from
    being embedded in the vernacular language of functions. </p>
    <pre><code><span class="hljs-comment">//You can use line comments</span>
    <span class="hljs-comment">/* and
    multiline
    comments
    */</span>
    
    custom<span class="hljs-number">_</span>alphabet = [a-z]
    binary<span class="hljs-number">_</span>alphabet = [<span class="hljs-number">0</span>-<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">function</span><span class="hljs-number">1</span> = <span class="hljs-string">'01'</span>:<span class="hljs-string">'011'</span> | <span class="hljs-string">''</span>:<span class="hljs-string">'10'</span>
    <span class="hljs-keyword">function</span><span class="hljs-number">1</span> &lt;: binary<span class="hljs-number">_</span>alphabet* &amp;&amp; binary<span class="hljs-number">_</span>alphabet*
    
    <span class="hljs-keyword">function</span><span class="hljs-number">2</span> = <span class="hljs-string">'functions can be reused '</span> <span class="hljs-keyword">function</span><span class="hljs-number">1</span> <span class="hljs-string">' like this'</span>
    <span class="hljs-comment">// It's actually more of a variable than a function at the moment </span>
    </code></pre><p>All automata are always guaranteed to be functional (at most one output is generated for every input).</p>
    <h2 id="type-system">Type system</h2>
    <p>The symbol <code>&lt;:</code> stands for ordering on types. For instance in Java you have <code>ArrayList&lt;X&gt; &lt;: List&lt;X&gt; &lt;: Collection&lt;X&gt; &lt;: Object</code>. It is a characterisitc feature of polymorphic type systems. In set-theoretic view one could see it as one type being a subset of another. Hence alternative notation allowed in Solomonoff is</p>
    <pre><code><span class="hljs-symbol">function1</span> ⊂ <span class="hljs-keyword">binary_alphabet* </span>&amp;&amp; <span class="hljs-keyword">binary_alphabet*</span>
    </code></pre><p>The symbol <code>&amp;&amp;</code> represents pairs. It&#39;s analogical to set-theoritic Cartesian product. Hence alternative notation is allowed here as well</p>
    <pre><code><span class="hljs-symbol">function1</span> ⊂ <span class="hljs-keyword">binary_alphabet* </span>⨯ <span class="hljs-keyword">binary_alphabet*</span>
    </code></pre><p>For example, the string <code>&#39;a&#39;</code> is an elements of formal language <code>{&#39;a&#39;}</code>, but writing those braces is cumbersome. The string <code>&#39;01010101&#39;</code> is an element of set <code>[0-1]*</code>. Moreover every string is an element of <code>.*</code>.</p>
    <p>The dot <code>.</code> stands for all possible symbols (except for <code>\0</code> which is not considered to be
    a &quot;possible&quot; symbol). </p>
    <pre><code><span class="hljs-attr">function3</span> = .* : <span class="hljs-string">'ala'</span> //rewrite anything to <span class="hljs-string">'ala'</span>
    </code></pre><p>Hence <code>.</code> is the alphabet ∑ and <code>\0</code> is assumed to be &quot;some symbol outside of alphabet&quot;. In fact you can write <code>Σ</code> instead of <code>.</code>. They are both synonymous.</p>
    <pre><code><span class="hljs-attr">function3</span> = Σ* : <span class="hljs-string">'ala'</span> //rewrite anything to <span class="hljs-string">'ala'</span>
    </code></pre><p>The type <code>.*</code> is the top type. Every string belongs to it. Conversely
    there is also the bottom type, denoted with <code>#</code>. No string belongs to <code>#</code> (not even <code>\0</code>).
    Notice that strings containing <code>\0</code> live completely outside of this type hierarchy.   </p>
    <pre><code><span class="hljs-keyword">function</span>2 = <span class="hljs-string">'this function has no type, hence it defaults to Σ* ⨯ Σ*'</span>
    
    <span class="hljs-keyword">function</span>3 = .* : <span class="hljs-string">'ala'</span>
    <span class="hljs-keyword">function</span>3 &lt;: .* &amp;&amp; .*  // <span class="hljs-built_in">type</span> of <span class="hljs-keyword">function</span>3
    
    <span class="hljs-keyword">function</span>4 = . : <span class="hljs-string">'test'</span>
    <span class="hljs-keyword">function</span>4 &lt;: [a-z] &amp;&amp; .* // <span class="hljs-built_in">type</span> of <span class="hljs-keyword">function</span>4
    </code></pre><p> It&#39;s possible to assign multiple types to a single function 
     (hence you can observe that the type system is polymorphic).</p>
    <pre><code>multiple_types = [a-z][a-x][b-z]    
    multiple_types &lt;: .* &amp;&amp; .*
    multiple_types &lt;: <span class="hljs-string">'abc'</span> &amp;&amp; .*
    multiple_types &lt;: [a-z] <span class="hljs-string">'bc'</span> &amp;&amp; .*
    multiple_types &lt;: [b-x][b-x][b-x] &amp;&amp; .*
    multiple_types &lt;: [b-x][b-x][b-x] &amp;&amp; <span class="hljs-string">''</span>
    
    //<span class="hljs-symbol">There</span> exists a lattice of types. 
    </code></pre><p>It&#39;s worth poining out that finite state automata (or more precisely finite state acceptors) are just a special case of transducers, that just happen to never return any output. Therefore a syntactic shugar is supported</p>
    <pre><code>acceptor = <span class="hljs-symbol">'i</span> never <span class="hljs-keyword">return</span> output'
    acceptor &lt;: ([a-z]|<span class="hljs-string">' '</span>)* 
    </code></pre><p>which translates to </p>
    <pre><code><span class="hljs-attribute">acceptor</span> = <span class="hljs-string">'i never return output'</span>
    acceptor &lt;: ([a-z]|<span class="hljs-string">' '</span>)* &amp;&amp; <span class="hljs-string">''</span>
    </code></pre><p>The <code>&#39;&#39;</code> is an empty string (a.k.a &quot;no output&quot;). In formal languages, it is often denoted with <code>ε</code>. In fact you can write</p>
    <pre><code> acceptor = <span class="hljs-symbol">'i</span> never <span class="hljs-keyword">return</span> output'
    acceptor &lt;: ([a-z]|<span class="hljs-string">' '</span>)* ⨯ ε
    </code></pre><p>and both notations are synonymous. One of them is just a bit prettier, while the other is easier to type.</p>
    <p>Apart from <code>&amp;&amp;</code> there is also one more type. </p>
    <pre><code><span class="hljs-function"><span class="hljs-title">f</span> &lt;: [a-z] -&gt;</span> .*
    </code></pre><p>The symbol <code>-&gt;</code> stands for function type. Alternative pretty notation is</p>
    <pre><code>f &lt;: <span class="hljs-string">[a-z]</span> → .*
    </code></pre><p>The most important difference between <code>&amp;&amp;</code> and <code>-&gt;</code> is in polymorphic variance. In order to understand it better you should remember that <code>&amp;&amp;</code> and <code>-&gt;</code> are not really types by themselves, but rather type constructors. Just like <code>|</code> takes two arguments and performs their union, the same holds here. <code>-&gt;</code> takes two arguments, which are types, and returns a third type (higher-order functions are not allowed, unfortunately). Consider a Java-like example of <code>Pair&lt;Cat,Dog&gt; &lt;: Pair&lt;Animal,Animal&gt;</code> and <code>Function&lt;Animal,Dog&gt; &lt;: Function&lt;Cat,Animal&gt;</code>. In order words, <code>&amp;&amp;</code> is covariant on both parameters, whereas <code>-&gt;</code> is contravariant on th left parameter and convariant on the right one. <strong>Note:</strong> typechecking <code>&amp;&amp;</code> is quadratic, whereas typechecking <code>-&gt;</code> is an exponential operation (becase covariance means checking if nondeterministic language is a <em>subset</em> of deterministic one, whereas contravariance is done by checking if nondeterministic language is a <em>superset</em> of deterministic one, which is equivalent to checking if deterministic is subset of nondeterministic, which is a hard problem). However most of the time, when automata are not too large, it should not be any problem.</p>
    <p>Notice that if <code>f</code> is of type <code>A -&gt; B</code> then any
    string accepted by <code>A</code> is also accepted by <code>f</code> but the opposite doesn&#39;t hold.
    Not all strings accepted by <code>f</code> are necessarily accepted by <code>A</code>.
    When it comes to output, the opposite holds. Every string returned/printed
    by <code>f</code> is accepted by <code>B</code> but not every string accepted by <code>B</code> can be
     printed by <code>f</code>. </p>
    <p>You can reuse functions as types for others. It&#39;s a very powerful feature.</p>
    <pre><code>x = <span class="hljs-string">'abc'</span>:<span class="hljs-string">'01f'</span> <span class="hljs-number">1</span> | <span class="hljs-string">'re'</span>:<span class="hljs-string">'2'</span> <span class="hljs-number">2</span>
    
    y = <span class="hljs-string">'abc'</span>:<span class="hljs-string">'43'</span> | <span class="hljs-string">'re'</span>:<span class="hljs-string">'kk'</span>
    y &lt;: x -&gt; .*
    <span class="hljs-regexp">//</span>everything that <span class="hljs-keyword">is</span> accepted <span class="hljs-keyword">by</span> x must
    <span class="hljs-regexp">//</span>also be accepted <span class="hljs-keyword">by</span> y
    
    z = <span class="hljs-string">'abc'</span>:<span class="hljs-string">'re'</span>
    z &lt;: <span class="hljs-string">'abc'</span> -&gt; x
    <span class="hljs-regexp">//</span>everything that <span class="hljs-keyword">is</span> printed <span class="hljs-keyword">by</span> z <span class="hljs-keyword">is</span> 
    <span class="hljs-regexp">//g</span>uaranteed to be accepted <span class="hljs-keyword">by</span> x
    </code></pre><p>This even has some resemblance to object-oriented
     programming with abstract classes and extensions.
     Here domain (left projection/input projection) of
     one transducer can be used as basis for another.</p>
    <p>This type-system is very expressive. You can easily 
     define finite state acceptors as a special
    case of transducers of type <code># -&gt; &#39;&#39;</code>.</p>
    <pre><code>plain_regex = <span class="hljs-string">'abc'</span> | <span class="hljs-string">'red'</span>*
    plain_regex &lt;: # -&gt; <span class="hljs-string">''</span>
    </code></pre><p>The symbol <code>#</code> stands for empty type (<code>Void</code> in Java/Haskell). No string belongs to <code>#</code> (not even <code>\0</code>). You can also literally write <code>∅</code> instead of <code>#</code>.</p>
    <pre><code><span class="hljs-attribute">plain_regex</span> ⊂ ∅ → ε
    </code></pre><p>Another interesting property is that you can easily check whether automaton
    is total (that is, every string is mapped to some other string and no input is rejected)</p>
    <pre><code>total = Σ* : <span class="hljs-comment">'a'</span>
    total &lt;: .* -&gt; <span class="hljs-comment">'a'</span>
    </code></pre><p>In order to check if automaton is empty (that is, all inputs are rejected) you
    can assert the following</p>
    <pre><code><span class="hljs-keyword">empty</span> = .* : <span class="hljs-string">'a'</span> <span class="hljs-comment">#</span>
    <span class="hljs-keyword">empty</span> &lt;: .* &amp;&amp; ∅
    </code></pre><p>or</p>
    <pre><code><span class="hljs-literal">empty</span> = .* : <span class="hljs-string">'a'</span> ∅
    <span class="hljs-literal">empty</span> &lt;: <span class="hljs-comment"># &amp;&amp; .*</span>
    </code></pre><p>because Cartesian product of any set with an empty set still yields an empty set. </p>
    <p>You can use letters for convenience, but in reality
    everything is a 32bit integer. You can specify<br>everything directly in integers if you wish.</p>
    <pre><code>with_integers = &lt;<span class="hljs-number">1</span>&gt; &lt;<span class="hljs-number">3</span>&gt; | (&lt;<span class="hljs-number">43</span>&gt; &lt;<span class="hljs-number">1243</span>&gt;)*
    int_ranges = &lt;<span class="hljs-number">1</span><span class="hljs-number">-54</span>&gt; | &lt;<span class="hljs-number">32</span><span class="hljs-number">-54</span>&gt; &lt;<span class="hljs-number">1</span>&gt; &lt;<span class="hljs-number">100</span><span class="hljs-number">-100</span>&gt;*  
    </code></pre><p>The dot <code>.</code> itself is not anything magical
    It&#39;s just a syntactic sugars for</p>
    <pre><code>// dots can <span class="hljs-keyword">be</span> used <span class="hljs-keyword">in</span> names <span class="hljs-keyword">of</span> variables
    . = &lt;1-2147483647&gt;
    //<span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> greek symbols
    Σ = .
    //<span class="hljs-keyword">and</span> hashtags <span class="hljs-keyword">and</span> ∅
    
    // Note <span class="hljs-keyword">that</span> 2147483647==Integer.MAX_VALUE
    </code></pre><p>The same goes for <code>#</code> and <code>∅</code>. It&#39;s also just a normal variable 
    (not a keyword). Unfortunately it&#39;s not possible to
    build empty transducer by hand, hence it&#39;s built into
    the compiler. </p>
    <h2 id="reflections">Reflections</h2>
    <p>This compiler employs one special optimisation technique.
    Because <code>\0</code> is not considered to be a possible &#39;normal&#39; symbol,
    it becomes interpreted as a &#39;special&#39; symbol instead.
    Whenever you write</p>
    <pre><code><span class="hljs-attr">mirror</span> = <span class="hljs-string">'reflect '</span>:&lt;<span class="hljs-number">0</span>&gt; [a-z] <span class="hljs-string">' input'</span> 
    </code></pre><p>The <code>&lt;0&gt;</code> is interpreted as &#39;reflection&#39; of input. Here
    is example of how evaluation of such expression would look like</p>
    <pre><code><span class="hljs-function"><span class="hljs-title">mirror</span><span class="hljs-params">(<span class="hljs-string">'reflect a input'</span>)</span></span>=<span class="hljs-string">'a'</span>
    <span class="hljs-function"><span class="hljs-title">mirror</span><span class="hljs-params">(<span class="hljs-string">'reflect b input'</span>)</span></span>=<span class="hljs-string">'b'</span> 
    ...
    <span class="hljs-function"><span class="hljs-title">mirror</span><span class="hljs-params">(<span class="hljs-string">'reflect z input'</span>)</span></span>=<span class="hljs-string">'z'</span> 
    </code></pre><p>This way instead of having to create 26 transitions labeled with
     <code>[a-a]:a</code>, <code>[b-b]:b</code>, ... <code>[c-c]:c</code>, compiler creates only one transition
     <code>[a-z]:&lt;0&gt;</code> that is interpreted in a special way during automaton
     evaluation. The type system is aware of this feature and in fact,
     can very efficiently test such reflected ranges. </p>
    <pre><code> mirror &lt;: # -&gt; [a-z] <span class="hljs-comment">// is true</span>
     mirror &lt;: # -&gt; [a-b] <span class="hljs-comment">// is false</span>
     mirror &lt;: # -&gt; <span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>|...|<span class="hljs-string">'z'</span> <span class="hljs-comment">// is true</span>
     mirror &lt;: # -&gt; . <span class="hljs-comment">// is true</span>
     mirror &lt;: # -&gt; <span class="hljs-string">'a'</span> <span class="hljs-comment">// is false</span>
    </code></pre><p>This feature is very useful for writing parts of
    regular expressions that leave most of input intact and rewrite
    only some interesting places. For instance here is how to implement
    a replace-all function</p>
    <pre><code><span class="hljs-attr">replace_abc_with_x</span> = (<span class="hljs-string">''</span>:&lt;<span class="hljs-number">0</span>&gt; . | <span class="hljs-string">'abc'</span>:<span class="hljs-string">'x'</span> <span class="hljs-number">1</span> )*
    </code></pre><p>Note that we have to write <code>&#39;&#39;:&lt;0&gt; .</code> instead of <code>.:&lt;0&gt;</code> because
    the mirror symbol <code>&lt;0&gt;</code> reflects input that appears after it (this follows directly from the nature of Glushkov&#39;s construction).</p>
    <h2 id="pseudo-minimization">Pseudo minimization</h2>
    <p>While Glushkov&#39;s construction by itself guarantees very small automata,
    they are always additionally compressed and optimised using a pseudo-minimization
    algorithm. For example a regular expression like</p>
    <pre><code>large_regex = <span class="hljs-variable">&lt;1&gt;</span> |<span class="hljs-string"> &lt;2&gt; </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> &lt;999&gt;</span>
    </code></pre><p>should have (according to Glushkov&#39;s algorithm) one thousand states.
    However, optimisation compresses it down to only 2 states and
    a thousand edges. Of course a much better approach would be</p>
    <pre><code><span class="hljs-attr">small_regex</span> = &lt;<span class="hljs-number">1</span>-<span class="hljs-number">999</span>&gt;
    </code></pre><p>which has only 2 states and one edge. A more interesting example would be</p>
    <pre><code><span class="hljs-attr">tricky_regex</span> = (<span class="hljs-string">'a'</span>:<span class="hljs-string">'y'</span> <span class="hljs-number">2</span> | <span class="hljs-string">'a'</span>:<span class="hljs-string">'x'</span> <span class="hljs-number">3</span>)(<span class="hljs-string">'b'</span>:<span class="hljs-string">'y'</span> <span class="hljs-number">2</span> | <span class="hljs-string">'b'</span>:<span class="hljs-string">'x'</span> <span class="hljs-number">3</span>)
    </code></pre><p>which should normally have 5 states, but gets compressed down to just 3, because
    the alternatives with lower weights can clearly be discarded.
    Notice that this compression algorithm is not the same as minimisation
    algorithm! In fact, because the automata are always nondeterministic,
    they are often already very small and and attempts at building minimal deterministic ones
    would either fail completely (nondeterministic functional transducers are strictly more
    powerful than deterministic ones) or yield (possibly exponentially) larger automata, than 
    their nondeterministic versions. Hence the pseudo-minimisation algorithm
    attempts to compress nondeterministic automata as much as possible, but doesn&#39;t
    try to find the smallest nondeterministic automaton possible (because the problem is hard
    and would consume too much resources without giving good results anyway).</p>
    <h2 id="external-functions">External functions</h2>
    <p>You can call external functions</p>
    <pre><code><span class="hljs-attr">automaton_built_from_java</span> = externalFuncName!(<span class="hljs-string">'arg1'</span>, <span class="hljs-string">'arg2'</span>, <span class="hljs-string">'arg3'</span>)
    </code></pre><p>Alternatively argument pairs are allowed:</p>
    <pre><code><span class="hljs-attr">automaton_built_from_java_with_labels</span> = externalFuncName!(<span class="hljs-string">'arg1'</span>:<span class="hljs-string">'label1'</span>, <span class="hljs-string">'arg2'</span>:<span class="hljs-string">'label2'</span>, <span class="hljs-string">'arg3'</span>:<span class="hljs-string">'label3'</span>)
    </code></pre><p>Those correspond respectively to text and informant (from the theory of inductive inference).
    The notation <code>&#39;input&#39;</code> is a syntactic sugar for <code>&#39;input&#39;:&#39;&#39;</code>, whereas <code>&#39;input&#39;:#</code> stands for negative
    example (the input is not accepted by the automaton). You can for instance use machine learning to 
    automatically build automata from examples</p>
    <pre><code><span class="hljs-attr">learned_from_text</span> = rpni!(<span class="hljs-string">'a'</span>, <span class="hljs-string">'aa'</span>:#, <span class="hljs-string">'aaa'</span>, <span class="hljs-string">'aaaa'</span>:#)
    <span class="hljs-attr">learned_from_informant</span> = rpni_mealy!(<span class="hljs-string">'a'</span>:<span class="hljs-string">'0'</span>, <span class="hljs-string">'aa'</span>:<span class="hljs-string">'01'</span>, <span class="hljs-string">'aaa'</span>:<span class="hljs-string">'010'</span>, <span class="hljs-string">'aaaa'</span>:<span class="hljs-string">'0101'</span>)
    </code></pre><p>There are the following learning functions available:</p>
    <pre><code>rpni!   - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> LearnLib
    rpni_edsm!   - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> LearnLib
    rpni_mdl!   - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> LearnLib
    rpni_mealy!   - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> LearnLib
    ostia!   - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> SolomonoffLib
    apti!    - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> SolomonoffLib
    oftia!   - <span class="hljs-keyword">provided</span> <span class="hljs-keyword">by</span> SolomonoffLib
    </code></pre><p>There are also some utility functions like</p>
    <pre><code>import!(<span class="hljs-symbol">'path</span>/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span>.mealy')
    stringFile!(<span class="hljs-symbol">'path</span>/<span class="hljs-keyword">to</span>/tab/separated/two-column/<span class="hljs-keyword">file</span>.tsv')
    dict!(<span class="hljs-symbol">'key1</span>':<span class="hljs-symbol">'replacement1</span>',<span class="hljs-symbol">'key2</span>':<span class="hljs-symbol">'replacement2</span>',...)
    </code></pre><p>Solomonoff also supports external operators. Their syntax uses square brackets instead. There are the following built-in external operators</p>
    <pre><code>compose<span class="hljs-string">[transducer1, transducer2, transducer3,...]</span>     
    inverse<span class="hljs-string">[transducer1]</span>
    stripOutput<span class="hljs-string">[transducer]</span>
    random<span class="hljs-string">[]</span>
    identity<span class="hljs-string">[transducer]</span>
    subtract<span class="hljs-string">[transducer1, transducer2]</span>
    </code></pre><p>For example</p>
    <pre><code>f = compose[<span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span>,<span class="hljs-string">'b'</span>:<span class="hljs-string">'c'</span>]<span class="hljs-comment">
    //f yields transducer that works like 'a':'c'</span>
    g = inverse[<span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span>]<span class="hljs-comment">
    //g yields transducer that works like 'b':'a'</span>
    h = stripOutput[<span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span>]<span class="hljs-comment">
    //h yields transducer that works like 'a'</span>
    i = identity[<span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span>]<span class="hljs-comment">
    //i yields transducer that works like 'a':'a'</span>
    j = <span class="hljs-built_in">subtract</span>[<span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>*, <span class="hljs-string">'b'</span>]<span class="hljs-comment">
    //j yields transducer that works like 'a'|ε|'b' 'b'+</span>
    </code></pre><p>Beware, because external operators bypass Glushkov&#39;s construction and all the nice guarantees about small number of states etc. migh be lost.
    Moreover, in case of any typchecking problems, the error messages might be less informative, because large portion of the information gets lost. In particular, Glushkov&#39;s construction allows the compiler to exactly know which state of automaton corresponds to which line of code. After performing <code>inverse[]</code> or <code>compose[]</code>, states of automata and lines of code become decoupled. </p>
    <h2 id="linear-types">Linear types</h2>
    <p>The vernacular language support linear typing. That is, you as a user have full control over how many copies of automata are made. This is critical feature in memory-constraint enviroments or a major optimisation when dealing with really large automata.</p>
    <p>Those familiar with Haskell might be used to the convention of writing types first and implementations second, like this:</p>
    <pre><code><span class="hljs-function"><span class="hljs-title">f</span> &lt;: .* -&gt;</span> [<span class="hljs-number">01</span>]+
    f = .* : <span class="hljs-string">''</span> | <span class="hljs-string">'aba'</span>:<span class="hljs-string">'bab'</span> <span class="hljs-number">2</span> | <span class="hljs-string">'aaa'</span>:<span class="hljs-string">'bbb'</span> <span class="hljs-number">2</span>
    </code></pre><p>However, in Solomonoff this will not compile. That&#39;s because we are trying to typecheck something that does not yet exist in linear context. The line with <code>f =</code> introduces a new variable. While Solomonoff could in theory go with the approach of declaring all types globally, letting the types be checked &quot;locally&quot; gives more flexibilty. You will see in a moment. </p>
    <p>The following snippet shows how one transducer can be resued to build another</p>
    <pre><code><span class="hljs-attr">f</span> = <span class="hljs-string">'aa'</span>:<span class="hljs-string">'a'</span>
    <span class="hljs-attr">g</span> = f <span class="hljs-string">'aa'</span>:<span class="hljs-string">'a'</span> 
    </code></pre><p>Due to linear typing, <code>f</code> is consumed while building <code>g</code> and we cannot use it anymore</p>
    <pre><code><span class="hljs-attr">f</span> = <span class="hljs-string">'aa'</span>:<span class="hljs-string">'a'</span>
    <span class="hljs-attr">g</span> = f <span class="hljs-string">'aa'</span>:<span class="hljs-string">'a'</span> // consumes f
    <span class="hljs-attr">h</span> = f <span class="hljs-string">'bb'</span>:<span class="hljs-string">'b'</span> // error! f not found
    </code></pre><p>If we want to reuse <code>f</code> again, we need to prevent it from being consumed. The only way to achieve it is by making a copy with the exponential operator <code>!!</code> (the word &quot;exponential&quot; here has nothing to do with exponential complexity. It&#39;s a linear-time and linear-space operation. However, linear logic has exponential operators and this is what <code>!!</code> refers to. Simply put, here exponential operator = copy operator). </p>
    <pre><code><span class="hljs-attr">f</span> = <span class="hljs-string">'aa'</span>:<span class="hljs-string">'a'</span>
    <span class="hljs-attr">g</span> = !!f <span class="hljs-string">'aa'</span>:<span class="hljs-string">'a'</span> // f is explicitly copied
    <span class="hljs-attr">h</span> = f <span class="hljs-string">'bb'</span>:<span class="hljs-string">'b'</span> // f is consumed
    </code></pre><p>Now imagine that you have some large transducer and you want to make just a few minor operations on it.</p>
    <pre><code><span class="hljs-attr">f</span> = dict!(<span class="hljs-string">'1'</span>:<span class="hljs-string">'one'</span>,<span class="hljs-string">'2'</span>:<span class="hljs-string">'two'</span>,...,<span class="hljs-string">'10000'</span>:<span class="hljs-string">'ten thousand'</span>)
    <span class="hljs-attr">g</span> = <span class="hljs-string">'prefix'</span> f
    <span class="hljs-attr">h</span> = g <span class="hljs-string">'suffix'</span>
    </code></pre><p>If Solomonoff didn&#39;t have linear types, this would require making 2 copies (3 instances in total) of that huge dictionary. With linear types there are no copies at all (only one instance). It saves a lot of space and time.</p>
    <p>An interesting feature of linear typing is beig able to &quot;redeclare&quot; or &quot;mutate&quot; variables.</p>
    <pre><code>f = <span class="hljs-symbol">'aa</span><span class="hljs-string">':'</span>a' // f introduced
    f = !!f f // first f <span class="hljs-keyword">is</span> copied, 
              // <span class="hljs-keyword">then</span> consumed <span class="hljs-keyword">and</span> 
              // <span class="hljs-keyword">then</span> a <span class="hljs-keyword">new</span> f <span class="hljs-keyword">is</span> introduced
    </code></pre><p>And both of those <code>f</code>s might have different types. That&#39;s why it&#39;s much better to have typechecker sensitive to linear contexts, rather than declaring types globally.</p>
    <pre><code>f = <span class="hljs-symbol">'aa</span>':<span class="hljs-symbol">'a</span>'
    f &lt;: .* &amp;&amp; <span class="hljs-symbol">'a</span>' // first <span class="hljs-built_in">time</span> checking <span class="hljs-keyword">type</span>
    f = !!f f
    f &lt;: .* &amp;&amp; <span class="hljs-symbol">'aa</span>' // second <span class="hljs-built_in">time</span> checking different <span class="hljs-keyword">type</span>
    </code></pre><p>There is one last feature, when it comes to linear types. Some automata are very tiny and reused all the time (like <code>.</code>). In those cases we might instruct Solomonoff to always assume copy implicitly.
    Instead of writing</p>
    <pre><code>. = &lt;<span class="hljs-number">1</span>-<span class="hljs-number">2147483647</span>&gt; //copy explicitly
    f = !!.* : <span class="hljs-string">'a'</span>
    f &lt;: !!.* &amp;&amp;  !!.*
    </code></pre><p>we can write</p>
    <pre><code>!!. = &lt;<span class="hljs-number">1</span>-<span class="hljs-number">2147483647</span>&gt; //<span class="hljs-keyword">copy</span><span class="bash"> implicitly everywhere
    </span>f = .* : <span class="hljs-string">'a'</span>
    f &lt;: .* &amp;&amp;  .*
    </code></pre><p>This is, in fact, the real way in which <code>.</code> is implemented internally.</p>
    <h2 id="composition">Composition</h2>
    <p>While Glushkov&#39;s construction has no means of supporting transducer composition (apart from calls to external operators, which bypass Glushkov&#39;s construction),
    Solomonoff provides this feature in a lazy manner (it&#39;s perferred and recommended over <code>compose[]</code>). In a sense, composition becomes
    a special language in itself. Solomonoff also borrows from Hoare logic to allow for
    formally verified correctness of all compositions.</p>
    <p>In order to define a composed function, you have to prefix its name with <code>@</code>.</p>
    <pre><code>@<span class="hljs-keyword">f</span> = <span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span>;
    </code></pre><p>Unlike in &quot;the usual&quot; functions, the composed functions have to be finalized with <code>;</code>.
    This syntax was inspired by Hoare triples. Here <code>&#39;a&#39;:&#39;b&#39;</code> becomes a statement with
    side-effects. You might alternatively think of it as if it was</p>
    <pre><code>String <span class="hljs-built_in">f</span>(String <span class="hljs-keyword">input</span>){
        <span class="hljs-keyword">input</span> = <span class="hljs-keyword">input</span>.<span class="hljs-keyword">replace</span>(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">input</span>;    
    }
    </code></pre><p>There is one string that is mutated by consecutive transducers. A more complex example might be</p>
    <pre><code>@f = <span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span> ; <span class="hljs-string">'b'</span> : '<span class="hljs-type">c</span> ;
    </code></pre><p>which would roughly have the same effect as</p>
    <pre><code>String <span class="hljs-built_in">f</span>(String <span class="hljs-keyword">input</span>){
        <span class="hljs-keyword">input</span> = <span class="hljs-keyword">input</span>.<span class="hljs-keyword">replace</span>(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>);
        <span class="hljs-keyword">input</span> = <span class="hljs-keyword">input</span>.<span class="hljs-keyword">replace</span>(<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">input</span>;    
    } 
    </code></pre><p>Now the best part is use of assertions similar to Hoare pre- and postconditions.</p>
    <pre><code>@f = <span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span> {<span class="hljs-string">'b'</span>} <span class="hljs-string">'b'</span> : '<span class="hljs-type">c</span> ;
    </code></pre><p>You might think of it in a sense as</p>
    <pre><code>String <span class="hljs-built_in">f</span>(String <span class="hljs-keyword">input</span>){
        <span class="hljs-keyword">input</span> = <span class="hljs-keyword">input</span>.<span class="hljs-keyword">replace</span>(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>);
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">input</span>.belongsTo(<span class="hljs-string">"b"</span>) ;
        <span class="hljs-keyword">input</span> = <span class="hljs-keyword">input</span>.<span class="hljs-keyword">replace</span>(<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">input</span>;    
    } 
    </code></pre><p>You can use even more complex expressions like</p>
    <pre><code>@f = <span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span> | <span class="hljs-string">'h'</span>:<span class="hljs-string">'i'</span> 
         {<span class="hljs-string">'b'</span>|<span class="hljs-string">'i'</span>} 
         <span class="hljs-string">'b'</span>:<span class="hljs-string">'c'</span> | <span class="hljs-string">'i'</span>:<span class="hljs-string">'j'</span> 
         {<span class="hljs-string">'c'</span>|<span class="hljs-string">'j'</span>} 
         <span class="hljs-string">'c'</span>:<span class="hljs-string">'d'</span> | <span class="hljs-string">'j'</span>:<span class="hljs-string">'k'</span>;
    </code></pre><p>Note that while the evaluation of transducers is lazy, the Hoare assertions
    are fully checked at compile-time and then erased. Therefore they don&#39;t
    add any performance penalty at runtime. Note that the above example translates exactly to</p>
    <pre><code>stateme<span class="hljs-symbol">nt1</span> = <span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span> | <span class="hljs-string">'h'</span>:<span class="hljs-string">'i'</span>
    stateme<span class="hljs-symbol">nt1</span> &lt;: <span class="hljs-attr"># -&gt; 'b'|'i'
    
    statement2</span> = <span class="hljs-string">'b'</span>:<span class="hljs-string">'c'</span> | <span class="hljs-string">'i'</span>:<span class="hljs-string">'j'</span>
    stateme<span class="hljs-symbol">nt2</span> &lt;: <span class="hljs-string">'b'</span>|<span class="hljs-string">'i'</span> -&gt;  <span class="hljs-string">'c'</span>|<span class="hljs-string">'j'</span>    
    
    stateme<span class="hljs-symbol">nt3</span> = <span class="hljs-string">'c'</span>:<span class="hljs-string">'d'</span> | <span class="hljs-string">'j'</span>:<span class="hljs-string">'k'</span>
    stateme<span class="hljs-symbol">nt3</span> &lt;: <span class="hljs-string">'c'</span>|<span class="hljs-string">'j'</span> -&gt; .*
    
    @f =  stateme<span class="hljs-symbol">nt1</span> ; stateme<span class="hljs-symbol">nt2</span> ; stateme<span class="hljs-symbol">nt3</span>
    </code></pre><p>The entire syntax of Hoare-triples is a essentially not much more than syntactic
    sugar. Note that it&#39;s possible to not only add Hoare assertions but also Hoare
    preconditions and postconditions.</p>
    <pre><code><span class="hljs-meta">@f</span> = {<span class="hljs-string">'a'</span> | <span class="hljs-string">'h'</span>} <span class="hljs-comment">//precondition</span>
         <span class="hljs-string">'a'</span>:<span class="hljs-string">'b'</span> | <span class="hljs-string">'h'</span>:<span class="hljs-string">'i'</span> 
         {<span class="hljs-string">'b'</span>|<span class="hljs-string">'i'</span>}  <span class="hljs-comment">//assertion</span>
         <span class="hljs-string">'b'</span>:<span class="hljs-string">'c'</span> | <span class="hljs-string">'i'</span>:<span class="hljs-string">'j'</span> 
         {<span class="hljs-string">'c'</span>|<span class="hljs-string">'j'</span>} <span class="hljs-comment">//assertion</span>
         <span class="hljs-string">'c'</span>:<span class="hljs-string">'d'</span> | <span class="hljs-string">'j'</span>:<span class="hljs-string">'k'</span>
         {<span class="hljs-string">'d'</span> | <span class="hljs-string">'k'</span>} <span class="hljs-comment">//postcondition</span>
    </code></pre><h2 id="usage">Usage</h2>
    <h4 id="build-jar-from-sources">Build jar from sources</h4>
    <p>You can compile the project using</p>
    <pre><code>mvn clean compile <span class="hljs-keyword">assembly</span>:<span class="hljs-built_in">single</span>
    </code></pre><p>Then you can run</p>
    <pre><code>java -jar target/solomonoff<span class="hljs-number">-1.5</span>-jar-<span class="hljs-keyword">with</span>-dependencies.jar
    </code></pre><h4 id="dowload-prepackaged-jar">Dowload prepackaged jar</h4>
    <p>Here is <a href="https://drive.google.com/file/d/1irvdvQrwI4p1zL-P9i_yd-GJP6zqX7fJ/view?usp=sharing">download link</a>. Then run</p>
    <pre><code><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">solomonoff-1</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-class">.jar</span>
    </code></pre><h4 id="repl-usage">REPL usage</h4>
    <p>Wait until you see</p>
    <pre><code>&gt;
    </code></pre><p>Then you can start using repl and typing code directly. You can also run REPL commands like</p>
    <pre><code>:eval [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span>] [input string]
    :rand_sample [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span>] of_size [<span class="hljs-built_in">size</span>]
    :rand_sample [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span>] of_length [length]
    :equal [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span> <span class="hljs-number">1</span>] [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span> <span class="hljs-number">2</span>]
    :is_det [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span>]
    :load [<span class="hljs-keyword">file</span> path]
    :ls
    :mem [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span>]
    :<span class="hljs-built_in">size</span> [<span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">name</span>]
    </code></pre><p>For example this</p>
    <pre><code>&gt;:load path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">some</span>/<span class="hljs-built_in">file</span>.mealy
    Success!
    &gt;:mem f
    <span class="hljs-number">1435</span>
    </code></pre><p>loads source code from file and returns RAM memory consumption of transducer defined under <code>f</code>. Note that <code>:mem</code> will not work unless you configure java to properly use instrumentation agent like so</p>
    <pre><code> java -javaagent:target/solomonoff<span class="hljs-number">-1.5</span>-jar-<span class="hljs-keyword">with</span>-dependencies.jar  -jar target/solomonoff<span class="hljs-number">-1.5</span>-jar-<span class="hljs-keyword">with</span>-dependencies.jar
    </code></pre><p>Another example evaluates transducer</p>
    <pre><code>&gt; mirror = <span class="hljs-string">'reflect '</span>:<span class="hljs-string">'&lt;0&gt; [a-z] '</span> input'
    Success!
    &gt;:eval mirror <span class="hljs-string">'reflect k input'</span>
    <span class="hljs-string">'k'</span>
    </code></pre><p>You can also get a full list of commands, along with their descriptions</p>
    <pre><code>&gt;:?
    </code></pre><p>Or you can query help of a single command</p>
    <pre><code>&gt;:?<span class="hljs-keyword">load</span>
    </code></pre><h4 id="programmatic-usage-from-java-api">Programmatic usage from java API</h4>
    <p>You can very easily use the compiler with Java API</p>
    <pre><code><span class="hljs-keyword">final</span> OptimisedHashLexTransducer compiled = <span class="hljs-keyword">new</span> OptimisedHashLexTransducer(
                    CharStreams.fromFileName(<span class="hljs-string">"some/file/path.mealy"</span>),<span class="hljs-keyword">true</span>);
    <span class="hljs-built_in">String</span> output = compiled.run(<span class="hljs-string">"function name"</span>,<span class="hljs-string">"input string"</span>);
    </code></pre><h5 id="maven">Maven</h5>
    <pre><code><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>solomonoff<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://raw.github.com/aleksander-mendoza/SolomonoffLib/repository/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.antlr<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>antlr4-runtime<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>solomonoff<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>solomonoff<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    
    </code></pre><h5 id="gradle">Gradle</h5>
    <pre><code><span class="hljs-keyword">repositories</span> {
        maven { url <span class="hljs-string">"https://raw.github.com/aleksander-mendoza/SolomonoffLib/repository/"</span> }
    }
    
    <span class="hljs-keyword">dependencies</span> {
        <span class="hljs-keyword">compile</span> <span class="hljs-keyword">group</span>: <span class="hljs-string">'solomonoff'</span>, name: <span class="hljs-string">'solomonoff'</span>, version:<span class="hljs-string">'1.2'</span>
        <span class="hljs-keyword">compile</span> <span class="hljs-keyword">group</span>: <span class="hljs-string">'org.antlr'</span>, name: <span class="hljs-string">'antlr4-runtime'</span>, version:<span class="hljs-string">'4.7.1'</span>
    }
    </code></pre><h2 id="references">References</h2>
    <ul>
    <li>The compiler is based on theory of monoidal languages<ul>
    <li>Finite-State Techniques: Automata, Transducers and Bimachines - Stoyan Mihov, Klaus U. Schulz</li>
    </ul>
    </li>
    <li>Nondeterministic minimisation was inspired by<ul>
    <li>On the State Minimization of Nondeterministic Finite Automata - Tsunehiko Kameda, Peter Weiner</li>
    <li>Brzozowski’s algorithm (co)algebraically - F. Bonchi, M.M. Bonsangue, J.J.M.M. Rutten, A.M. Silva</li>
    </ul>
    </li>
    <li>We developed lexicographic arctic semiring<ul>
    <li><a href="https://www.researchgate.net/publication/343211963_Multitape_automata_and_finite_state_transducers_with_lexicographic_weights">Multitape automata and finite state transducers with lexicographic weights - Aleksander Mendoza</a> </li>
    </ul>
    </li>
    <li>We developed inference algorithm for nondeterministic functional transducers<ul>
    <li><a href="https://www.researchgate.net/publication/344842995_Nondeterministic_functional_transducer_inference_algorithm">Nondeterministic functional transducer inference algorithm - Aleksander Mendoza-Drosik</a></li>
    </ul>
    </li>
    <li>Glushkov&#39;s construction has been adapted to functional transducers<ul>
    <li><a href="https://www.researchgate.net/publication/343471022_Glushkov&#39;s_construction_for_functional_subsequential_transducers">Glushkov&#39;s construction for functional subsequential transducers - Aleksander Mendoza</a></li>
    </ul>
    </li>
    </ul>
    <h2 id="benchmarks-thrax-vs-solomonoff">Benchmarks Thrax vs Solomonoff</h2>
    <h3 id="first-benchmarks-with-dictionary-without-cdrewrite">First: benchmarks with dictionary without CDRewrite</h3>
    <h4 id="1-solomonoff-without-dict-function">1. Solomonoff without dict!() function</h4>
    <p>Compilation time (including nondeterministic minimisation + checking for ambiguity)</p>
    <pre><code>$ java -jar target/solomonoff-<span class="hljs-number">1.4</span>-jar-with-dependencies<span class="hljs-selector-class">.jar</span> <span class="hljs-number">6000</span><span class="hljs-selector-class">.mealy</span>
    Parsing took <span class="hljs-number">2007</span> miliseconds  &lt;--- this includes <span class="hljs-selector-tag">time</span> of minimisation
    Optimising took <span class="hljs-number">0</span> miliseconds
    Checking ambiguity <span class="hljs-number">183</span> miliseconds
    Typechecking took <span class="hljs-number">0</span> miliseconds
    All loaded correctly! Total <span class="hljs-selector-tag">time</span> <span class="hljs-number">2190</span> miliseconds
    </code></pre><p>File format:</p>
    <pre><code>f = <span class="hljs-symbol">'Wand</span> -<span class="hljs-type">Verschmelzungseinstellungen'</span>:<span class="hljs-symbol">'Wand</span> <span class="hljs-type">Verschmelzungseinstellungen'</span>         
     | <span class="hljs-symbol">'Wand</span>-<span class="hljs-type">Verschmelzungseinstellungen'</span>:<span class="hljs-symbol">'Wand</span> <span class="hljs-type">Verschmelzungseinstellungen'</span>         
     | <span class="hljs-symbol">'Preis</span> <span class="hljs-type">Leistungs</span> <span class="hljs-type">Verh</span>ältnissen':<span class="hljs-symbol">'Preis</span>-<span class="hljs-type">Leistungs</span>-<span class="hljs-type">Verh</span>ältnissen'         
     | <span class="hljs-symbol">'Preis</span> <span class="hljs-type">Leistungs</span> <span class="hljs-type">Verh</span>ältnisses':<span class="hljs-symbol">'Preis</span>-<span class="hljs-type">Leistungs</span>-<span class="hljs-type">Verh</span>ältnisses'         
     | <span class="hljs-symbol">'Preis</span> <span class="hljs-type">Leistungs</span> <span class="hljs-type">Verh</span>ältnisse':<span class="hljs-symbol">'Preis</span>-<span class="hljs-type">Leistungs</span>-<span class="hljs-type">Verh</span>ältnisse'
     ... <span class="hljs-number">6333</span>,<span class="hljs-number">1</span> lines ...
     | <span class="hljs-symbol">'ok'</span>: <span class="hljs-symbol">'OK'</span>
    </code></pre><h4 id="2-solomonoff-execution-time">2. Solomonoff execution time</h4>
    <pre><code>f O.K.
    <span class="hljs-keyword">Output</span>: OK
    Took <span class="hljs-number">11</span> miliseconds  
    
    f Wand-Verschmelzungseinstellungen
    <span class="hljs-keyword">Output</span>: Wand Verschmelzungseinstellungen
    Took <span class="hljs-number">1</span> miliseconds
    
    f Wand-VerschmelzungseinstellungenWand-Verschmelzungseinstellunge 
    <span class="hljs-keyword">Output</span>: <span class="hljs-built_in">null</span>
    Took <span class="hljs-number">0</span> miliseconds
    
    f Wand-VerschmelzungseinstellungenWand-VerschmelzungseinstellungenWand-Verschmelzungseinstellungen
    <span class="hljs-keyword">Output</span>: <span class="hljs-built_in">null</span>
    Took <span class="hljs-number">1</span> miliseconds
    
    f Wand-Verschmelzungseinstellungen
    <span class="hljs-keyword">Output</span>: Wand Verschmelzungseinstellungen
    Took <span class="hljs-number">1</span> miliseconds
    
    f Wand-VerschmelzungseinstellungenWand-Verschmelzungseinstellungen
    <span class="hljs-keyword">Output</span>: <span class="hljs-built_in">null</span>
    Took <span class="hljs-number">2</span> miliseconds
    
    f fliesskommaberechnungen
    <span class="hljs-keyword">Output</span>: fließkommaberechnungen
    Took <span class="hljs-number">1</span> milisecond
    </code></pre><p>The initial call took 11 miliseconds, while all subsequent were only 0-2 miliseconds. It might be thanks to java&#39;s  JIT compiler. For comparison, using plain java HashMap also takes 0-2 miliseconds.</p>
    <h4 id="3-solomonoff-size-summary">3. Solomonoff size summary</h4>
    <table >
    <tbody>
      <tr>
        <td>Size of automaton (in states)</td>
        <td>19898</td>
      </tr>
      <tr>
        <td>Size of automaton (in states)<br>when minimization is disabled</td>
        <td>75864</td>
      </tr>
      <tr>
        <td>Number of letters in 6000.mealy</td>
        <td>198559</td>
      </tr>
      <tr>
        <td>Size of automaton after exporting <br>to binary file</td>
        <td>552KB</td>
      </tr>
      <tr>
        <td>Size of 6000.mealy</td>
        <td>202KB</td>
      </tr>
      <tr>
        <td>Size of 6000.mealy.gz</td>
        <td>45KB</td>
      </tr>
    </tbody>
    </table>
    
    <p>While it&#39;s disappointing that archive file is so large, it&#39;s not surprising that it&#39;s 
    larger than the regular expression itself. However, thanks to the compilation time being 
    so fast, it&#39;s in fact recommended to use logical representation of automata rather than binary. 
    After compressing 6000.mealy with gzip, its size falls down to 45KB. 
    Therefore the best approach would be to zip regular expressions and then compile them on application startup.
    You may treat it as &quot;domain specific compression algorithm&quot; that takes longer but gives much better results. </p>
    <h4 id="4-solomonoff-with-dict-function">4. Solomonoff with dict!() function</h4>
    <p>All the benchmarks above were made by compiling plain regular expressions. However, it&#39;s unfair because Thrax has StringFile function that is optimised for loading dictionaries. Solomonoff also has such function and it&#39;s called dict!().</p>
    <p>The file:</p>
    <pre><code>f = dict!(<span class="hljs-string">'Wand -Verschmelzungseinstellungen'</span>:<span class="hljs-string">'Wand Verschmelzungseinstellungen'</span>  
       , <span class="hljs-string">'Wand-Verschmelzungseinstellungen'</span>:<span class="hljs-string">'Wand Verschmelzungseinstellungen'</span>      
       , <span class="hljs-string">'Preis Leistungs Verhältnissen'</span>:<span class="hljs-string">'Preis-Leistungs-Verhältnissen'</span>
       ....
       , <span class="hljs-string">'ok'</span>: <span class="hljs-string">'OK'</span>)
    </code></pre><p>Compilation time:</p>
    <pre><code>$ java -jar target/solomonoff<span class="hljs-number">-1.4</span>-jar-<span class="hljs-keyword">with</span>-dependencies.jar orth_dict.mealy 
    Parsing took <span class="hljs-number">701</span> miliseconds  &lt;<span class="hljs-comment">--- includes minimisation</span>
    Optimising took <span class="hljs-number">0</span> miliseconds
    Checking ambiguity <span class="hljs-number">116</span> miliseconds
    Typechecking took <span class="hljs-number">0</span> miliseconds
    All loaded correctly! Total <span class="hljs-built_in">time</span> <span class="hljs-number">817</span> miliseconds
    Now instead <span class="hljs-keyword">of</span> <span class="hljs-number">2</span> <span class="hljs-built_in">seconds</span> <span class="hljs-keyword">it</span> takes only <span class="hljs-number">800</span> milis. The resulting automata are identical whether <span class="hljs-keyword">using</span> dict!() <span class="hljs-keyword">or</span> plain regexes.
    </code></pre><h4 id="5-solomonoff-with-stringfile-function">5. Solomonoff with stringFile!() function</h4>
    <pre><code>$ java -jar target/solomonoff<span class="hljs-number">-1.4</span>-jar-with-dependencies.jar orth_stringsFile.mealy  Parsing took <span class="hljs-number">473</span> miliseconds  &lt;--- includes minimisation
    Optimising took <span class="hljs-number">0</span> miliseconds
    Checking ambiguity <span class="hljs-number">107</span> miliseconds
    Typechecking took <span class="hljs-number">0</span> miliseconds
    All loaded correctly! Total time <span class="hljs-number">580</span> miliseconds
    </code></pre><p>While dict!() is parsed directly from source code, stringFile!() is used as follows:</p>
    <pre><code><span class="hljs-attr">f</span> = stringFile!(<span class="hljs-string">'orth.map'</span>)
    </code></pre><p>so it allows for bypassing the overhead of parser altogether. It reduces time to half a second.</p>
    <h4 id="6-thrax-without-stringfile-">6. Thrax without StringFile[]</h4>
    <pre><code> <span class="hljs-keyword">Parse</span> Failed: <span class="hljs-keyword">memory</span> exhausted
    </code></pre><p>cannot deal with such large files</p>
    <pre><code><span class="hljs-keyword">export</span> f = (<span class="hljs-string">"Wand -Verschmelzungseinstellungen"</span>:<span class="hljs-string">"Wand -Verschmelzungseinstellungen"</span>)
     | (<span class="hljs-string">"Wand-Verschmelzungseinstellungen"</span>:<span class="hljs-string">"Wand-Verschmelzungseinstellungen"</span>)
     ... <span class="hljs-number">6000</span> lines ...
     | (<span class="hljs-string">"ok"</span>:<span class="hljs-string">"OK"</span>);
    </code></pre><h4 id="7-thrax-with-stringfile-">7. Thrax with StringFile[]</h4>
    <p>Here thrax is much faster and takes only a few miliseconds. </p>
    <pre><code><span class="hljs-attribute">export f</span> = StringFile[<span class="hljs-string">'orth.map'</span>];
    </code></pre><h4 id="8-thrax-execution-time">8. Thrax execution time</h4>
    <p>Similar time to Solomonoff. Seems a few miliseconds slower, but it&#39;s hard to judge, due to overhead of linux&#39;es time command. Hence I will just assume it&#39;s on par with Solomonoff.</p>
    <h3 id="second-benchmarks-with-dictionary-wrapped-in-cdrewrite">Second: benchmarks with dictionary wrapped in CDRewrite</h3>
    <h4 id="1-thrax-with-stringfile-cdrewrtie-optimize">1. Thrax with StringFile[] + CDRewrtie + Optimize</h4>
    <pre><code>import 'byte.grm' as bytelib;
    star = <span class="hljs-keyword">Optimize</span>[bytelib.kBytes*];
    lb = <span class="hljs-keyword">Optimize</span>[<span class="hljs-string">" "</span>|<span class="hljs-string">"[BOS]"</span>];
    rb = <span class="hljs-keyword">Optimize</span>[<span class="hljs-string">" "</span>|<span class="hljs-string">"[EOS]"</span>];
    export f = <span class="hljs-keyword">Optimize</span>[CDRewrite[StringFile[<span class="hljs-string">'orth.map'</span>],lb,rb,star]];
    </code></pre><p>Takes 19 minutes</p>
    <pre><code>$ time make
    thraxcompiler --<span class="hljs-attr">input_grammar=</span>orth.grm --<span class="hljs-attr">output_far=</span>orth.far
    Evaluating <span class="hljs-keyword">rule</span>: star
    Evaluating <span class="hljs-keyword">rule</span>: lb
    Evaluating <span class="hljs-keyword">rule</span>: rb
    Evaluating <span class="hljs-keyword">rule</span>: f
    real    <span class="hljs-number">19m</span>1.<span class="hljs-number">016s</span>
    <span class="hljs-keyword">user</span>    <span class="hljs-title">18m59</span>.<span class="hljs-number">460s</span>
    sys     <span class="hljs-number">0m</span>1.<span class="hljs-number">448s</span>
    </code></pre><h4 id="2-thrax-execution-time">2. Thrax execution time</h4>
    <p>Now it works much slower</p>
    <pre><code><span class="hljs-built_in">time</span> echo <span class="hljs-string">"dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen"</span> | thraxrewrite-tester --far=<span class="hljs-built_in">orth</span>.far --rules=f 
    Input <span class="hljs-keyword">string</span>: 
    <span class="hljs-keyword">Output</span> <span class="hljs-keyword">string</span>: dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen 
    <span class="hljs-built_in">real</span> <span class="hljs-number">0</span>m0<span class="hljs-number">.285</span>s <span class="hljs-comment">// 285 miliseconds </span>
    user <span class="hljs-number">0</span>m0<span class="hljs-number">.265</span>s 
    sys <span class="hljs-number">0</span>m0<span class="hljs-number">.020</span>s
    </code></pre><p>Note that 20 miliseconds seems to be the overhead of time command and startup of thraxrewrite-tester. The remaining 260 miliseconds is the actual execution of transducer.</p>
    <h4 id="3-thrax-size">3. Thrax size</h4>
    <p>The produced <code>far</code> file has 27M! Much more than Solomonoff.</p>
    <h4 id="4-solomonoff-kleene-closure-compilation-">4. Solomonoff + Kleene closure (compilation)</h4>
    <p> The effect of CDRewrite can be achieved in Solomonoff just by wrapping everything in Kleene closure like this:</p>
    <pre><code>g = <span class="hljs-string">'Wand -Verschmelzungseinstellungen'</span>:<span class="hljs-string">'Wand Verschmelzungseinstellungen'</span>        
     | <span class="hljs-string">'Wand-Verschmelzungseinstellungen'</span>:<span class="hljs-string">'Wand Verschmelzungseinstellungen'</span>       
     | <span class="hljs-string">'Preis Leistungs Verhältnissen'</span>:<span class="hljs-string">'Preis-Leistungs-Verhältnissen'</span>        
     | <span class="hljs-string">'Preis Leistungs Verhältnisses'</span>:<span class="hljs-string">'Preis-Leistungs-Verhältnisses'</span>        
     | <span class="hljs-string">'Preis Leistungs Verhältnisse'</span>:<span class="hljs-string">'Preis-Leistungs-Verhältnisse'</span> 
     ... <span class="hljs-number">6333</span>,<span class="hljs-number">1</span> lines ... 
     | <span class="hljs-string">'ok'</span>: <span class="hljs-string">'OK'</span>
    
    f = (<span class="hljs-string">' '</span>:<span class="hljs-string">' '</span> g <span class="hljs-string">' '</span>:<span class="hljs-string">' '</span> <span class="hljs-number">2</span> | <span class="hljs-string">''</span>:&lt;<span class="hljs-number">0</span>&gt; . <span class="hljs-number">1</span>)*
    </code></pre><p>It takes only 4 seconds to load</p>
    <pre><code>Parsing took <span class="hljs-number">3621</span> miliseconds
    Optimising took <span class="hljs-number">0</span> miliseconds
    Checking ambiguity <span class="hljs-number">336</span> miliseconds
    Typechecking took <span class="hljs-number">0</span> miliseconds
    All loaded correctly! Total time <span class="hljs-number">3957</span> miliseconds
    </code></pre><h4 id="5-solomonoff-kleene-closure-execution-time-">5. Solomonoff + Kleene closure (execution time)</h4>
    <p>It takes only 0-1 milisecond to execute</p>
    <pre><code>f dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
    dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen
    Took <span class="hljs-number">7</span> miliseconds  &lt;--- again, probably fault of JIT compilation
    
    f dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
    dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen
    Took <span class="hljs-number">1</span> miliseconds
    
    f dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
    dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen
    Took <span class="hljs-number">1</span> miliseconds
    
    f dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
    dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen
    Took <span class="hljs-number">2</span> miliseconds
    
    f  dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
     dawfgre zweiunddreißigstelnoten hrth rh Fliesskommaberechnungen
    Took <span class="hljs-number">0</span> miliseconds
    
    f  dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
     dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen
    Took <span class="hljs-number">1</span> miliseconds
    
    f  dawfgre zweiunddreissigstelnoten hrth rh Fliesskommaberechnungen
     dawfgre zweiunddreißigstelnoten hrth rh Fließkommaberechnungen
    Took <span class="hljs-number">0</span> miliseconds
    </code></pre><h4 id="6-solomonoff-with-stringfile-kleene-closure">6. Solomonoff with stringFile!() + Kleene closure</h4>
    <pre><code>f = (<span class="hljs-name">stringFile!</span>('orth.map') <span class="hljs-number">2</span> | ''<span class="hljs-symbol">:&lt;0&gt;</span> . <span class="hljs-number">1</span> )*
    </code></pre><p>Takes only 2 seconds to load and results in identical transucer</p>
    <h4 id="7-solomonoff-kleene-closure-automaton-size-">7. Solomonoff + Kleene closure (automaton size)</h4>
    <p>Glushkov&#39;s construction guarantees only as many states as there are input symbols. 
    Minimisation reduces it even further. 
    So the size should be equal to the size of automaton without Kleene closure.</p>
    <h4 id="solomonoff-vs-thrax-ram-usage">Solomonoff vs Thrax RAM usage</h4>
    <p>The ram usage estimations are very broad. Generally it&#39;s difficult to benchmark 
    RAM usage of Java applications, due to platform-dependent internal representation of
    of classes. It&#39;s even more difficult to compare Java with C which use drastically different
    memory models. Therefore those benchmarks should only be seen as a broad estimate and taken with 
    a grain of salt.</p>
    <p>We will measure RAM usage of Solomonoff transducers using 
    <code>MemoryMeter.measureDeep</code> which under the hood uses <code>Instrumentation.getSizeOf</code>. 
    This will give us an estimate size of any class.  Moreover, keep in mind that Solomonoff
    has two data stuctures for representing transducers. One if mutable and takes up much more memory,
    whereas the other is immutable, more compact and is optimised for execution. To replicate our 
    results you would need to</p>
    <pre><code>OptimisedHashLexTransducer compiler = <span class="hljs-literal">new</span> OptimisedHashLexTransducer(<span class="hljs-params">...</span>);
    RangedGraph&lt;Pos, <span class="hljs-built_in">Integer</span>, E, P&gt; optimisedTransducer = compiler.getOptimisedTransducer(<span class="hljs-string">"nameOfFunction"</span>);
    compiler = <span class="hljs-built_in">null</span>;
    System.gc(); <span class="hljs-comment">// let GC remove mutable transducers that were stored in compiler</span>
    <span class="hljs-comment">//now we are only left with optimisedTransducer, which is fair, because this is the only thing that</span>
    <span class="hljs-comment">//you need when you decide to ship your code for production.</span>
    </code></pre><p>According to <code>measureDeep</code>, the transducer compiled from the same file as above  takes up</p>
    <pre><code><span class="hljs-symbol">738296 </span>bytes
    </code></pre><p>This transducer has 19898 states. </p>
    <p>Now in order to benchmark Thrax, we first compiled a very small transducer</p>
    <pre><code><span class="hljs-attribute">export f</span> = <span class="hljs-string">"a"</span>:<span class="hljs-string">"b"</span>;
    </code></pre><p>the we ran</p>
    <pre><code><span class="hljs-comment">thraxrewrite</span><span class="hljs-literal">-</span><span class="hljs-comment">tester</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">far=dummy</span><span class="hljs-string">.</span><span class="hljs-comment">far</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rules=f</span>
    </code></pre><p>and using UNIX <code>pmap</code> command we queried the memory usage of <code>thraxrewrite-tester</code>.
    We got the total of <code>37848K</code>. Next we compiled the actual grammar using</p>
    <pre><code><span class="hljs-attribute">export f</span> = StringFile[<span class="hljs-string">'orth.map'</span>];
    </code></pre><p>and ran <code>pmap</code> again. This time we got <code>31512K</code>. Assuming all other things being constant,
    and being hopeful that Thrax manages its memory in best possible way (has no memory leaks and no logical memory leaks,
    that is, chunks of data that are stored even though logically they are not used anymore),<br> we can conclude that the memory usage of transducer itself is around <code>37848K - 31512K = 6336K</code> in Thrax. 
    Comparing with Solomonoff&#39;s <code>738K</code> it&#39;s a huge difference. And let&#39;s not forget that Java 
    is in greatly disadvantaged position, because every class we store has some extra overhead, 
    that C wouldn&#39;t need to pay.</p>
    


  
</div>

</main>

<footer class="container">
    <p>© AMU 2019-2020</p>
</footer>



<!--<app-content ng-version="10.1.5"></app-content></body><div></div></html>-->